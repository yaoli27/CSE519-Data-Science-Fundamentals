# -*- coding: utf-8 -*-
"""Copy of CSE519_HW3_Template.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tbBHLbpDX6VO_0bxdOvAbhHCrJPVuX7Z

# Homework 3 - TMDB Box Office Prediction

For all parts below, answer all parts as shown in the Google document for Homework 3. Be sure to include both code that justifies your answer as well as text to answer the questions. Show runtime results for each cell. We also ask that code be commented to make it easier to follow.
"""

from google.colab import drive
drive.mount('/content/gdrive')

cd '/content/gdrive/My Drive/519/HW3'

!pip install catboost
!pip install ipywidgets
!jupyter nbextension enable --py widgetsnbextension

# Commented out IPython magic to ensure Python compatibility.
import numpy as np 
import pandas as pd 
import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline
import ast
import copy
from collections import Counter
import datetime
from wordcloud import WordCloud
import xgboost as xgb
import lightgbm as lgb
import catboost as cat
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
from sklearn import preprocessing
from sklearn.model_selection import KFold
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import StratifiedKFold
from sklearn.model_selection import permutation_test_score

"""# Part 1 - Data Cleaning and Reformatting"""

# load data
train=pd.read_csv("train.csv")
test=pd.read_csv("test.csv")

train.head()

"""## 1. Reformating

Dict Columns:
"""

reformat_columns = ['belongs_to_collection', 'genres', 'production_companies','production_countries', 'spoken_languages', 'Keywords', 'cast', 'crew']

# transfer from string to list of dicts
def str_to_dict(x):
  if pd.isna(x):
    x = {0}
  else:
    x = ast.literal_eval(x)
  return x

for col in reformat_columns:
  train[col] = train[col].apply(str_to_dict)
  test[col] = test[col].apply(str_to_dict)
train[reformat_columns].head()

# keep useful part from dict
string_space = 'name'

def extract_name(x):
  y=[]
  if x != {0}:
    for i in x:
      #print(i['name'])
      y.append(i[string_space])
    x=y
    #print(y)
  else:
    x = []
  return x

train['belongs_to_collection'] = train['belongs_to_collection'].apply(extract_name)
test['belongs_to_collection'] = test['belongs_to_collection'].apply(extract_name)

list_of_genres = train['genres'].apply(extract_name)
train['genres'] = train['genres'].apply(extract_name)
test['genres'] = test['genres'].apply(extract_name)

list_companies = train['production_companies'].apply(extract_name)
train['production_companies'] = train['production_companies'].apply(extract_name)
test['production_companies'] = test['production_companies'].apply(extract_name)

string_space = 'iso_3166_1'
list_of_countries = train['production_countries'].apply(extract_name)
train['production_countries'] = train['production_countries'].apply(extract_name)
test['production_countries'] = test['production_countries'].apply(extract_name)

string_space = 'iso_639_1'
list_of_spoken_lang = train['spoken_languages'].apply(extract_name)
train['spoken_languages'] = train['spoken_languages'].apply(extract_name)
test['spoken_languages'] = test['spoken_languages'].apply(extract_name)

string_space = 'name'
#train['cast_name'] = train['cast'].apply(extract_name)

list_keyword = train['Keywords'].apply(extract_name)
train['Keywords'] = train['Keywords'].apply(extract_name)
test['Keywords'] = test['Keywords'].apply(extract_name)

train[reformat_columns].head()

"""Realease Date:"""

train['release_date'] = pd.to_datetime(train['release_date'])

def fix_date(x):
    if x.year > 2017:
        year = x.year - 100
    else:
        year = x.year
    return datetime.date(year,x.month,x.day)

train['release_date'] = train['release_date'].apply(fix_date)

# insert year, month, weekday columns
train.insert(14,"year",pd.to_datetime(train["release_date"]).dt.strftime('%Y').astype(int))
train.insert(15,"month",pd.to_datetime(train["release_date"]).dt.strftime('%m').astype(int))
train.insert(16,"weekday",pd.to_datetime(train["release_date"]).dt.strftime('%A'))
train.insert(17,"day_of_week",pd.to_datetime(train["release_date"]).dt.strftime('%w').astype(int))

test.loc[test['release_date'].isna(),'release_date'] = '1/5/20'
test['release_date'] = pd.to_datetime(test['release_date'])
test['release_date'] = test['release_date'].apply(fix_date)

test.insert(14,"year",pd.to_datetime(test["release_date"]).dt.strftime('%Y').astype(int))
test.insert(15,"month",pd.to_datetime(test["release_date"]).dt.strftime('%m').astype(int))
test.insert(16,"weekday",pd.to_datetime(test["release_date"]).dt.strftime('%A'))
test.insert(17,"day_of_week",pd.to_datetime(test["release_date"]).dt.strftime('%w').astype(int))

train[['release_date']].head()

"""##2. Data Cleaning

**Runtime:**
"""

train['runtime'].describe()

#train runtime
runtime_na = train[train['runtime'].isna()][['id','title','runtime','release_date','imdb_id']]
runtime_zero = train.loc[train['runtime']==0,['id','title','runtime','release_date','imdb_id']]
runtime_anom = pd.concat([runtime_zero,runtime_na])
runtime_anom

# fill with accurate data

train.loc[train['id']==391,'runtime']= 86
train.loc[train['id']==592,'runtime']= 90
train.loc[train['id']==925,'runtime']= 86
train.loc[train['id']==978,'runtime']= 93
train.loc[train['id']==1256,'runtime']= 92
train.loc[train['id']==1542,'runtime']= 93
train.loc[train['id']==1875,'runtime']= 86
train.loc[train['id']==2151,'runtime']= 108
train.loc[train['id']==2499,'runtime']= 86
train.loc[train['id']==2646,'runtime']= 98
train.loc[train['id']==2786,'runtime']= 101
train.loc[train['id']==2866,'runtime']= 96
train.loc[train['id']==1336,'runtime']= 130
train.loc[train['id']==2303,'runtime']= 108

test.loc[test['id'] == 3244,'runtime'] = 93 
test.loc[test['id'] == 4490,'runtime'] = 90 
test.loc[test['id'] == 4633,'runtime'] = 108 
test.loc[test['id'] == 6818,'runtime'] = 90 
test.loc[test['id'] == 4074,'runtime'] = 103 
test.loc[test['id'] == 4222,'runtime'] = 91 
test.loc[test['id'] == 4431,'runtime'] = 96
test.loc[test['id'] == 5520,'runtime'] = 86
test.loc[test['id'] == 5845,'runtime'] = 83 
test.loc[test['id'] == 5849,'runtime'] = 140 
test.loc[test['id'] == 6210,'runtime'] = 104
test.loc[test['id'] == 6804,'runtime'] = 140 
test.loc[test['id'] == 7321,'runtime'] = 87

train['runtime'].describe()

"""**Budget:**"""

train['budget'].describe()

low_budget = train[train["budget"] <= 1000]

sns.stripplot(x='budget', y='revenue', data = low_budget, jitter=True)
plt.xlabel('Budget')
plt.ylabel('Revenue')
plt.title('Revenues of low-budget movies')
plt.show()

low_budget[low_budget["revenue"] >= 100000000][['id','budget','original_title','year','imdb_id','revenue']]

# fill those have the most difference (budget <= 1000 & revenue>100000000)

train.loc[train.id == 90,'budget'] = 30000000
train.loc[train.id == 118,'budget'] = 60000000
train.loc[train.id == 149,'budget'] = 18000000
train.loc[train.id == 464,'budget'] = 20000000
train.loc[train.id==470,'budget'] = 13000000
train.loc[train.id == 819,'budget'] = 90000000
train.loc[train.id == 1112,'budget'] = 6000000
train.loc[train.id == 1131,'budget'] = 4300000
train.loc[train.id == 1359,'budget'] = 10000000
train.loc[train.id == 1570,'budget'] = 15800000
train.loc[train.id == 1714,'budget'] = 46000000
train.loc[train.id == 1865,'budget'] = 80000000
train.loc[train.id == 2602,'budget'] = 31000000

train.loc[train.id == 850,'budget'] = 1500000  # Modern Times
train.loc[train.id == 2256,'budget'] = 1500000  # Lost & Found
train.loc[train.id == 335,'budget'] = 1848922 #Saamy

# na values
train.loc[train['id']==334,'budget'] = 1820717
train.loc[train['id']==645,'budget'] = 1810798
train.loc[train['id']==1668,'budget'] = 1820717
train.loc[train['id']==2324,'budget'] = 403251

# for test budget, fix the wrong scale
low_budget_test = test[test["budget"] <= 1000]
for index, row in low_budget_test.iterrows():
  if row['budget'] < 100:
    test.loc[test.index==index,'budget'] = test.loc[test.index==index,'budget'] * 1000000
  elif row['budget'] < 1000:
    test.loc[test.index==index,'budget'] = row['budget'] * 1000

## for 0 values, fill zero value with mean budget per year
year_list = train['year'].unique()

#train budget
for year in year_list:
    year_mean = train[(train['year']==year) & (train['budget']!=0)]['budget'].mean()
    if year_mean != np.nan:
      train[train["year"]==year] = train[train["year"]==year].replace({"budget": 0}, year_mean)
#test budget
for year in year_list:
    year_mean = test[(test['year']==year) & (test['budget']!=0)]['budget'].mean()
    if year_mean != np.nan:
      test[test["year"]==year] = test[test["year"]==year].replace({"budget": 0}, year_mean)

# for the rest small budgets
low_budget = train[(train["budget"] <= 100) & (train["revenue"] > 100)][['id','budget','original_title','year','imdb_id','revenue']]
low_budget

train.loc[train['id']==513,'budget'] = 1100000 # From Prada to Nada
train.loc[train['id']==797,'budget'] = 8000000 # 웰컴 투 동막골
train.loc[train['id']==2696,'budget'] = 10000000 # Nurse 3-D
train.loc[train.index==1800,'budget'] = 5000000 # The Cherry Orchard

low_budget = train[train["budget"] <= 1000]
sns.stripplot(x='budget', y='revenue', data = low_budget, jitter=True)
plt.xlabel('Budget')
plt.ylabel('Revenue')
plt.title('Revenues of low-budget movies')
plt.show()

"""Most budget with anomalies are fixed."""

train[train["budget"] <= 100][['id','budget','original_title','year','imdb_id','revenue']]

"""These low-budget data might have some scaling problems, so they could be dealt with revenue together.

**Revenue:**
"""

fig, ax = plt.subplots(figsize = (16, 4))
plt.subplot(1, 2, 1)
plt.hist(train['revenue']);
plt.title('Distribution of revenue');
plt.subplot(1, 2, 2)
plt.hist(np.log1p(train['revenue']));
plt.title('Distribution of log of revenue');

# fix the revenue with wrong scale
low_revenue = train.loc[train['revenue']<100,['budget','original_title','imdb_id','year','revenue']]

fix_idx = [150,280,450,1138,1198,1281,1884,2399,2433,2474]
for index, row in low_revenue.iterrows():
  if index in fix_idx:
    train.loc[train.index==index,'revenue'] = train.loc[train.index==index,'revenue'] * 1000
    if row['budget'] < 10:
      train.loc[train.index==index,'budget'] = row['budget'] * 1000
  elif row['revenue'] < 10:
    train.loc[train.index==index,'revenue'] = row['revenue'] * 1000000
    if row['budget'] < 20:
      train.loc[train.index==index,'budget'] = row['budget'] * 1000000
  else:
    train.loc[train.index==index,'revenue'] = row['revenue'] * 1000
    if row['budget'] < 1000:
      train.loc[train.index==index,'budget'] = row['budget'] * 1000

# revenue that not following the rules
train.loc[train.index==579,'revenue'] = 2400000 #Blood on the moon
train.loc[train.index==1006,'revenue'] = 30 # Zyzzyx Road
train.loc[train.index==1346,'revenue'] = 24079 # East of Eden
train.loc[train.index==2117,'revenue'] = 344992 # American Adobo
train.loc[train.index==2759,'revenue'] = 1694899 # Dou Sing2

# revenue with 3 digits
medium_revenue = train.loc[((train['revenue']>=100) & (train['revenue']<=1000)),['budget','original_title','imdb_id','year','revenue']]

for index, row in medium_revenue.iterrows():
  train.loc[train.index==index,'revenue'] = row['revenue'] * 1000

fig, ax = plt.subplots(figsize = (16, 4))
plt.subplot(1, 2, 1)
plt.hist(train['revenue']);
plt.title('Distribution of revenue');
plt.subplot(1, 2, 2)
plt.hist(np.log1p(train['revenue']));
plt.title('Distribution of log of revenue');

"""The distribution of log_revenue is no longer as skewed as before.

# Part 2 - Word Cloud
"""

list_all_genres = []
for x in list_of_genres:
  for i in range(len(x)):
    list_all_genres.append(x[i])
list_all_genres[:5]

genres_values, genres_counts = np.unique(list_all_genres, return_counts=True)
wordcloud_genres = Counter(list_all_genres)
wordcloud_genres.most_common(4)

plt.figure(figsize=(18,6))
wordcloud = WordCloud(max_font_size=None, background_color='white', collocations=False,width=1200, height=1000).generate_from_frequencies(wordcloud_genres)
plt.imshow(wordcloud)
plt.title('genres',size=24)
plt.axis("off")
plt.show()

list_all_keyword = []
for x in list_keyword:
  for i in range(len(x)):
    list_all_keyword.append(x[i])
list_all_keyword[:5]

wordcloud_keywords = Counter(list_all_keyword)
wordcloud_keywords.most_common(4)

plt.figure(figsize=(18,6))
wordcloud = WordCloud(max_font_size=None, background_color='white', collocations=False,width=1200, height=1000).generate_from_frequencies(wordcloud_keywords)
plt.imshow(wordcloud)
plt.title('Keywords',size=24)
plt.axis("off")
plt.show()

list_all_original_titles = []
for x in train['original_title']:
  list_all_original_titles.append(x)
list_all_original_titles[:3]

wordcloud_orig_title = ' '.join(list_all_original_titles)

plt.figure(figsize=(18,6))
wordcloud = WordCloud(max_font_size=None, background_color='white', collocations=False,width=1200, height=1000).generate(wordcloud_orig_title)
plt.imshow(wordcloud)
plt.title('Original Titles',size=24)
plt.axis("off")
plt.show()

list_all_overview = []
for x in train['overview']:
  if (type(x)==str):
    list_all_overview.append(x)
list_all_overview[:3]

wordcloud_overview = ' '.join(list_all_overview)

plt.figure(figsize=(18,6))
wordcloud = WordCloud(max_font_size=None, background_color='white', collocations=False,width=1200, height=1000).generate(wordcloud_overview)
plt.imshow(wordcloud)
plt.title('Overview',size=24)
plt.axis("off")
plt.show()

"""# Part 3 - Time Series Analysis"""

days = [ 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
mons = [ '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12']

train.groupby('weekday')['imdb_id'].count().reindex(days).plot(kind='bar')

plt.title("Release Movies by weekday", size=14)
plt.xticks(rotation=45)
plt.ylabel('Count')
plt.show()

"""Most of the movies released on Friday, so that people can go to see the movies on weekends."""

train.groupby('month')['imdb_id'].count().plot(kind='bar')
plt.title("Release Movies by month", size=14)
plt.xticks(rotation=0)
plt.ylabel('Count')
plt.show()

"""September and October has the most released movie number. In other months there isn't an obvious trending."""

year_list.tolist()
year_list.sort()

plt.figure(figsize=(25,10))
train.groupby('year')['imdb_id'].count().reindex(year_list).plot(kind='bar')
plt.title("Released Movies by year", size=12)
plt.xticks(rotation = 40)
plt.ylabel('Count')
plt.show()

"""Starting from the late 70's, the number of released films has a  tremendous growth, indicating there is a big market in this area.<br> In 2017 there are not many records, leading a huge decreasing.

# Part 4 - Cast Power
"""

# extract the cast name
train['cast_name'] = train['cast'].apply(extract_name)
test['cast_name'] = test['cast'].apply(extract_name)
train[['cast_name']].head()

"""1) Actor Power Score (APS)<br/>
Compute each actor’s ‘Actor
Power Score (APS)’ by counting the number of times this actor
appears in the dataset.
"""

# split the cast list
list_all_cast = []
for x in train['cast_name']:
  for i  in x:
    list_all_cast.append(i)
list_all_cast[:5]

# count the occurence
cast_values, cast_counts = np.unique(list_all_cast, return_counts=True)
cast_count_pair = list(zip(cast_values,cast_counts))
cast_count_pair.sort(key = lambda x: x[1],reverse=True)
cast_count_pair[:10]

"""2) Average Actor Star-power (AvAS)  = Total Actor Star-power (TAS)  / Number of Actors(NAct)<br> For each movie the dataset, add the power scores of all the actors in the movie to compute the ‘Total Actor Star-power (TAS)’ of it.<br>Then divide this by the number of actors (NAct) in the movie to
calculate the ‘Average Actor Star-power (AvAS)’.
"""

# Total Actor Star-power (TAS)
cast_pair_dict = dict(cast_count_pair)

def actor_power_count(x):
  score = 0
  for i in x:
    if i in cast_pair_dict.keys():
      score += cast_pair_dict[i]
  return score

def cast_power(df):
  # total cast power
  df['total_cast_power'] = df['cast_name'].apply(actor_power_count)
  
  #cast count
  df['cast_count'] = df['cast_name'].apply(lambda x: len(x) if x != {0} else 0)

  # cast power = total_cast_power / cast_count
  df['cast_power'] = df['total_cast_power'] / df['cast_count']
  df['cast_power'] = df['cast_power'].fillna(df['cast_power'].mean())

  #normalization
  df['norm_cast_power'] = df['cast_power'].apply(lambda x: (x - df['cast_power'].min() ) / ( df['cast_power'].max()-df['cast_power'].min()))

  df['log_cast_power'] = np.log1p(df['cast_power'])
  df['log_budget'] = np.log1p(df['budget'])
  if 'revenue' in df.columns.values:
    df['log_revenue'] = np.log1p(df['revenue'])

  return df

train = cast_power(train)
test = cast_power(test)
train[['total_cast_power','cast_count','cast_power','norm_cast_power']].head()

plt.scatter(train['cast_power'],train['log_revenue'])
plt.title('cast power vs. revenue');
plt.xlabel('cast_power')
plt.ylabel('revenue')
plt.show()

diff = train[['cast_power','total_cast_power','log_cast_power','revenue','log_revenue']]
corr = diff.corr(method="pearson")
corr[['cast_power','total_cast_power','log_cast_power']]

sns.heatmap(corr[['cast_power','total_cast_power','log_cast_power']], annot=True)
plt.show()

"""***Cast power*** does show some relation with revenue, and ***Total Cast Power*** shows a higher value, but not as high as other features like budgets. <br>

# Part 5 - External Dataset
"""

print("train shape before: ",train.shape)

train_add = pd.read_csv('TrainAdditionalFeatures.csv')
test_add = pd.read_csv('TestAdditionalFeatures.csv')

train = pd.merge(train, train_add, how='left', on=['imdb_id'])
test = pd.merge(test, test_add, how='left', on=['imdb_id'])

print("train shape after: ",train.shape)

train.columns.shape,test.columns.shape

train['rating'] = train['rating'].fillna(1.5)
train['totalVotes'] = train['totalVotes'].fillna(6)

test['rating'] = test['rating'].fillna(1.5)
test['totalVotes'] = test['totalVotes'].fillna(6)

train['popularity2'] = train['popularity2'].fillna(train.groupby(['original_language','year'])['popularity2'].transform('mean'))
test['popularity2'] = test['popularity2'].fillna(test.groupby(['original_language','year'])['popularity2'].transform('mean'))

corr_matrix = train[['budget','rating','totalVotes','popularity','popularity2','revenue']]
f,ax = plt.subplots(figsize=(10, 8))
sns.heatmap(corr_matrix.corr(), annot=True)
plt.show()

"""###Analysis:
Data set source: https://www.kaggle.com/kamalchhirang/tmdb-competition-additional-features <br/>
What information it contains: This data set contains the rating, total votes and popularity. <br/>From the corrlation heatmap, ***total votes*** and  ***popularity2*** have a high correlation with revenue, so it would be helpful to use it in later analysis.

# Part 6 - Informative Plots

### Plot 1: Revenue by year
"""

#fig,ax=plt.subplots()
plt.figure(figsize=(20,8))
ax = train.groupby('year')['revenue'].mean().reindex(year_list.sort()).plot( color='skyblue',marker = 'o',label='revenue_mean')
ax.set_ylabel("Amount")
ax = train.groupby('year')['revenue'].median().reindex(year_list.sort()).plot(marker = 'o',label='revenue_median')
ax = train.groupby('year')['budget'].mean().reindex(year_list.sort()).plot(color='coral',marker = '+',label='budget_median')
ax.figure.legend(loc='center')
plt.xticks(np.arange(1920,2018,10), rotation=70,size=10)
plt.show()

"""1. Revenue Info: <br/>The mean revenue has increasing a lot during these years. However, the  median revenue does not increase much all the time. The mean value could be effected by the extrem high revenue, thus median may be a better indicator of the revenue change.<br/>Both the mean and median revenue have an obious peak in the 70s, indicating that there is indeed a popularity at that time.<br/>
2. Budget and Revenue: <br/>From the median budget and revenue we can see that, the budget over the years is increasing, but the revenue does not increase accordingly. Thus although the numbers of released movies grows a lot, the film industry may not make much profit these years.

### Plot2: How the genres effect revenue
"""

# create a genres dict to store number of movies in each genre.
genres_dict = dict()

for genre in train["genres"]:
    for elem in genre:
        if elem not in genres_dict:
            genres_dict[elem] = 1
            #print('1',elem)
        else:
            genres_dict[elem] += 1
            #print('2',elem)

genres_df = pd.DataFrame.from_dict(genres_dict, orient='index')
genres_df.columns = ["count_of_genres"]
genres_df = genres_df.sort_values(by="count_of_genres", ascending=False)
genres_df.head()

genres_split = pd.DataFrame()
genres_values, genres_counts = np.unique(list_all_genres, return_counts=True)

for g in genres_values:
    genres_split['genres_' + g] = train['genres'].apply(lambda x: 1 if g in x else 0)

for index, genres in enumerate(genres_df.index.values):
    genres_df.loc[genres, "median_revenue"] = train[genres_split['genres_' + genres]==1].revenue.median()

genres_df.sort_values(by=["count_of_genres", "median_revenue"], ascending=False)
genres_df.drop('TV Movie',inplace=True)
genres_df.head()

plt.figure(figsize=(15,7))
ax1 = genres_df['count_of_genres'].plot(kind='bar')
ax2 = genres_df['median_revenue'].plot(secondary_y=True, marker = 'o',color='coral')

ax2.set_title("Genres: Counts and Revenue", size=14)
ax1.set_ylabel("movies of genres",size=12)
ax2.set_ylabel('median revenue per genre',size=12)
for label in ax1.get_xticklabels():
    label.set_ha("center")
    label.set_rotation(30)

ax2.axhline(train['revenue'].median(),color='coral',linestyle='--')
plt.show()

"""From the plot, ***Drama, Comdedy, Thriller*** are the top 3 genres that have the most numbers. <br/>However, they are not the ones that make the most revenue. Instead, the revenue shows an opposite trend. <br>Thus, just making movies of the top genres may not guarantee profits.

### Plot 3: Production Companies with Revenue
"""

# create a genres dict to store number of movies in each genre.
company_dict = dict()

for comp in train["production_companies"]:
    for elem in comp:
        if elem not in company_dict:
            company_dict[elem] = 1
            #print('1',elem)
        else:
            company_dict[elem] += 1
            #print('2',elem)
comp_df = pd.DataFrame.from_dict(company_dict, orient='index')
comp_df.columns = ["count_of_movies"]
comp_df = comp_df.sort_values(by="count_of_movies", ascending=False)

list_all_companies = []
for x in list_companies:
  for i in range(len(x)):
    list_all_companies.append(x[i])

company_values, company_counts = np.unique(list_all_companies, return_counts=True)
company_count_pair = list(zip(company_values,company_counts))
company_count_pair.sort(key = lambda x: x[1],reverse=True)

top10_companies = []
for p in company_count_pair[:10]:
  top10_companies.append(p[0])

comp_split = pd.DataFrame()
comp_values, comp_counts = np.unique(list_all_companies, return_counts=True)

for g in top10_companies:
    comp_split['comp_' + g] = train['production_companies'].apply(lambda x: 1 if g in x else 0)


for index, company in enumerate(comp_df.head(10).index.values):
   comp_df.loc[company, "median_revenue"] = train[comp_split['comp_' + company]==1].revenue.median()
   #comp_df.loc[company, "mean_budget"] = train[comp_split['comp_' + company]==1].budget.mean()
   #comp_df.loc[company, "mean_popularity"] = train[comp_split['comp_' + company]==1].popularity.mean()

comp_df.sort_values(by=["count_of_movies"], ascending=False)
comp_df = comp_df.head(10)
comp_df

plt.figure(figsize=(13,6))
ax1 = comp_df['count_of_movies'].plot(kind='bar')
ax2 = comp_df['median_revenue'].plot(secondary_y=True, marker = 'o',color='coral')
#ax3 = comp_df['mean_budget'].plot(secondary_y=True, marker = 'o',color='r')

ax2.set_title("Production Companies: Counts and Revenue", size=14)
ax1.set_ylabel("count of movies",size=12)
ax2.set_ylabel('median revenue',size=12)
for label in ax1.get_xticklabels():
    label.set_ha("right")
    label.set_rotation(20)
ax2.axhline(train['revenue'].median(),color = 'coral',linestyle='--')
plt.show()

"""***Warner Bros, Universal Pictures, Paramount Pictures*** are the top 3 companies that make the most movies. <br/>Almost all top10 companies make revenue far more than the average, except ***Metro-Goldwyn-Mayer***.<br>***Walt Disney Pictures*** makes the highest revenue among all top10 companies, which is around 8 times more than the average revenue.

### Plot4: Other features and their relations with revenue
"""

fig, axs = plt.subplots(1,3,figsize=(20,6))

sns.regplot(x=train["budget"],y=train["revenue"],ax=axs[0])

sns.regplot(x=train["totalVotes"],y=train["revenue"],ax=axs[1])

sns.regplot(x=train["rating"],y=train["revenue"],ax=axs[2])

fig.suptitle('Budget, Total Votes, Rating vs. Revnue', position=(.5,1), fontsize=14)
plt.show()

"""From the plots we can see that, ***budget*** and ***total votes*** show a higher relation with revenue, while ***rating*** shows a much weaker relation. <br>Thus a good movie may not represent a high revenue.

### Plot 5: Binary features and revenue
"""

#binary features
train['has_collection'] = train['belongs_to_collection'].apply(lambda x: len(x) if x != {0} else 0)
train['has_homepage'] = 0
train.loc[train['homepage'].isnull() == False, 'has_homepage'] = 1
train['has_tagline'] = 0
train.loc[train['tagline'].isnull() == False, 'has_tagline'] = 1

test['has_collection'] = test['belongs_to_collection'].apply(lambda x: len(x) if x != {0} else 0)
test['has_homepage'] = 0
test.loc[test['homepage'].isnull() == False, 'has_homepage'] = 1
test['has_tagline'] = 0
test.loc[test['tagline'].isnull() == False, 'has_tagline'] = 1

train["is_orig_eng"] = train['original_language'].apply(lambda x: 1 if x == "en" else 0)
test["is_orig_eng"] = test['original_language'].apply(lambda x: 1 if x == "en" else 0)

fig, axs = plt.subplots(1,4,figsize=(24,6))

sns.stripplot(x="has_tagline", y="revenue", data=train,ax=axs[0])
sns.stripplot(x="has_homepage", y="revenue", data=train,ax=axs[1])
sns.stripplot(x="has_collection", y="revenue", data=train,ax=axs[2])
sns.stripplot(x="is_orig_eng", y="revenue", data=train,ax=axs[3])

fig.suptitle('Revenue vs. Binary Features', position=(.5,1), fontsize=14)
plt.show()

"""From the binary features plot we can see that, English movies or those have the tagline and homepage will make a lot more revenue. <br/>As for the collection, if a movie has a collection, it will also make more revenue, but not as much as the other flag features. <br/>
In brief, the prferrable properties of a movie are: <br>1) having a tagline or a homepage, <br>2) English as the original language, <br>3) being in  a collection.

# Part 7 - Pairwise Pearson Correlation
"""

def gender_count(x,code):
  gender_sum=0
  #print(type(i['gender']))
  for i in x:
    try:
      if(i['gender'] == code):
        gender_sum +=1
    except:
      gender_sum+=0
  return gender_sum

for i in range(3):
  train['num_gender'+str(i)+"_cast"] = train['cast'].apply(lambda x: gender_count(x,i))
  train['num_gender'+str(i)+"_crew"] = train['crew'].apply(lambda x: gender_count(x,i))
  test['num_gender'+str(i)+"_cast"] = test['cast'].apply(lambda x: gender_count(x,i))
  test['num_gender'+str(i)+"_crew"] = test['crew'].apply(lambda x: gender_count(x,i))

## new features

train['crew_name'] = train['crew'].apply(extract_name)
test['crew_name'] = test['crew'].apply(extract_name)

num_columns = ['genres','production_companies','production_countries','spoken_languages','Keywords','cast_name','crew_name']
for col in num_columns:
  train['num_'+ col] = train[col].apply(lambda x: len(x) if x != {0} else 0)
  test['num_'+ col] = test[col].apply(lambda x: len(x) if x != {0} else 0)

len_columns = ['tagline','overview','title']
for col in len_columns:
  train['len_'+ col] = train[col].map(lambda x: len(str(x).split()))
  test['len_'+ col] = test[col].map(lambda x: len(str(x).split()))

def new_feature_df(df):
  df['popularity_mean_year']=df['popularity']/df.groupby("year")["popularity"].transform('mean')
  df['runtime_to_mean_year'] = df['runtime'] / df.groupby("year")["runtime"].transform('mean')
  df['budget_to_mean_year'] = df['budget'] / df.groupby("year")["budget"].transform('mean')
  return df

train = new_feature_df(train)
test =new_feature_df(test)

corr_matrix = train[['revenue','budget','rating','totalVotes','popularity','popularity2','num_gender1_cast','num_gender2_cast', 
                     'crew_name',  'num_gender1_crew','num_gender2_crew','num_genres','num_production_companies', 'num_spoken_languages', 'num_Keywords',
                     'num_cast_name', 'num_crew_name','popularity_mean_year','runtime_to_mean_year']]
f,ax = plt.subplots(figsize=(20, 12))
sns.heatmap(corr_matrix.corr(), annot=True)
plt.show()

"""**Most positive correlation:** total votes & revenue, buget-to-mean-year & revenue<br>
**Most negative correlation:** num_spoken_languages & num_gender1_cast<br>
It is also interesting to see that *the number of female crew* has a relative high relation with *revenue, total votes* and *popularity*.

# Part 8 - Regression and Permutation Test

### Budget
"""

X_train, X_test, y_train, y_test = train_test_split(np.log1p(train['budget']).values,train['log_revenue'])
X_train = X_train.reshape(-1,1)
X_test = X_test.reshape(-1,1)
reg = LinearRegression().fit(X_train, y_train)

score, permutation_scores, pvalue = permutation_test_score(reg, X_test, y_test, scoring="neg_root_mean_squared_error", n_permutations=100)
plt.hist(permutation_scores, 20, label='Permutation scores')
ylim = plt.ylim()
plt.vlines(score, ylim[0], ylim[1], linestyle='--',color='g', linewidth=3, label='Classification Score (pvalue %s)' % pvalue)
plt.legend()
plt.xlabel('Budget Score')
plt.show()

"""### Year"""

X_train, X_test, y_train, y_test = train_test_split(train['year'].values,train['log_revenue'])
X_train = X_train.reshape(-1,1)
X_test = X_test.reshape(-1,1)
reg = LinearRegression().fit(X_train, y_train)

score, permutation_scores, pvalue = permutation_test_score(reg, X_test, y_test, scoring="neg_root_mean_squared_error", n_permutations=100)
plt.hist(permutation_scores, 20, label='Permutation scores')
ylim = plt.ylim()
plt.vlines(score, ylim[0], ylim[1], linestyle='--',color='g', linewidth=3, label='Classification Score (pvalue %s)' % pvalue)
plt.legend()
plt.xlabel('Year Score')
plt.show()

"""### Total Votes"""

X_train, X_test, y_train, y_test = train_test_split(train['totalVotes'].values,train['log_revenue'])
X_train = X_train.reshape(-1,1)
X_test = X_test.reshape(-1,1)
reg = LinearRegression().fit(X_train, y_train)

score, permutation_scores, pvalue = permutation_test_score(reg,X_test, y_test, scoring="neg_root_mean_squared_error", n_permutations=100)
plt.hist(permutation_scores, 20, label='Permutation scores')
ylim = plt.ylim()
plt.vlines(2 *[score], ylim[0], ylim[1], linestyle='--',color='g', linewidth=3, label='Classification Score (pvalue %s)' % pvalue)
plt.legend()
plt.xlabel('Popularity Score')
plt.show()

"""***Budget*** and ***Total Votes*** should have a relatively high relation with revenue, while ***year*** should not. <br>The permutation test plot proved this pattern.

# Part 9 - Predicton
"""

## top 30 companies
list_all_companies = []
for x in list_companies:
  for i in range(len(x)):
    list_all_companies.append(x[i])
company_values, company_counts = np.unique(list_all_companies, return_counts=True)
company_count_pair = list(zip(company_values,company_counts))
company_count_pair.sort(key = lambda x: x[1],reverse=True)

top_30_companies = []
for p in company_count_pair[:30]:
  top_30_companies.append(p[0])


## top 15 countries
list_all_countries = []
for x in list_of_countries:
  for i in range(len(x)):
    list_all_countries.append(x[i])
country_values, country_counts = np.unique(list_all_countries, return_counts=True)
country_count_pair = list(zip(country_values,country_counts))
country_count_pair.sort(key = lambda x: x[1],reverse=True)

top_15_contries = []
for p in country_count_pair[:15]:
  top_15_contries.append(p[0])

#top 20 crew job
string_space = 'job'
train['crew_job'] = train['crew'].apply(extract_name)
test['crew_job'] = test['crew'].apply(extract_name)

list_all_crew_job = []
for x in train['crew_job']:
  for i in range(len(x)):
    list_all_crew_job.append(x[i])

crew_job_values, crew_job_counts = np.unique(list_all_crew_job, return_counts=True)
crew_job_count_pair = list(zip(crew_job_values,crew_job_counts))
crew_job_count_pair.sort(key = lambda x: x[1],reverse=True)

top_20_jobs = []
for p in crew_job_count_pair[:20]:
  top_20_jobs.append(p[0])

# top crew department
string_space = 'department'
train['crew_department'] = train['crew'].apply(extract_name)
test['crew_department'] = test['crew'].apply(extract_name)

list_all_crew_depart = []
for x in train['crew_department']:
  for i in range(len(x)):
    list_all_crew_depart.append(x[i])

crew_depart_values, crew_depart_counts = np.unique(list_all_crew_depart, return_counts=True)

#top original language
n_language = train.loc[:train.index[-1], "original_language"].value_counts()
large_language = n_language[n_language>=16].index
train.loc[~train["original_language"].isin(large_language), "original_language"] = "small"

top_orig_lang = list(large_language)
top_orig_lang.append('small')

# encoding 
for c in top_30_companies:
    train['prod_company_' + c] = train['production_companies'].apply(lambda x: 1 if c in x else 0)
    test['prod_company_' + c] = test['production_companies'].apply(lambda x: 1 if c in x else 0)

for c in top_15_contries:
    train['prod_country_' + c] = train['production_countries'].apply(lambda x: 1 if c in x else 0)
    test['prod_country_' + c] = test['production_countries'].apply(lambda x: 1 if c in x else 0)

for g in genres_values:
    train['genre_'+g] = train['genres'].apply(lambda x: 1 if g in x else 0)
    test['genre_'+g] = test['genres'].apply(lambda x: 1 if g in x else 0)

for j in top_20_jobs:
    train['job_'+j] = train['crew_job'].apply(lambda x: 1 if j in x else 0)
    test['job_'+j] = test['crew_job'].apply(lambda x: 1 if j in x else 0)

for l in top_orig_lang:
    train['orig_lang_'+l] = train['original_language'].apply(lambda x: 1 if l in x else 0)
    test['orig_lang_'+l] = test['original_language'].apply(lambda x: 1 if l in x else 0)

for d in crew_depart_values:
    train['depart_'+d] = train['crew_department'].apply(lambda x: 1 if d in x else 0)
    test['depart_'+d] = test['crew_department'].apply(lambda x: 1 if d in x else 0)

def prepare_df(df):
  df['budget_runtime_ratio']=df['budget']/df['runtime']
  df['budget_popularity_ratio']=df['budget']/df['popularity']
  df['budget_popularity2_ratio'] = df['budget']/df['popularity2']
  df['budget_year_ratio']=df['budget']/(df['year']*df['year'])
  df['popularity_totalVotes_ratio']=df['totalVotes']/df['popularity']
  df['rating_totalVotes_ratio']=df['totalVotes']/df['rating']
  df['totalVotes_releaseYear_ratio']=df['totalVotes']/df['year']
  df['budget_rating_ratio']=df['budget']/df['rating']
  df['budget_totalVotes_ratio']=df['budget']/df['totalVotes']
  return df

train = prepare_df(train)
test = prepare_df(test)
train.shape,test.shape

train_use = train.drop(['id','belongs_to_collection','genres','homepage','imdb_id','original_language','original_title','overview','poster_path',
                     'production_companies','production_countries','release_date','weekday','cast_count', 'norm_cast_power','crew_job', 'crew_department','spoken_languages','status',
                     'tagline','title','Keywords','cast','cast_name','crew','crew_name','genre_TV Movie','depart_Actors',
                     'cast_power','log_cast_power','revenue','log_revenue'],axis=1)

test_use = test.drop(['id','belongs_to_collection','genres','homepage','imdb_id','original_language','original_title','overview','poster_path',
                     'production_companies','production_countries','release_date','weekday','cast_count','norm_cast_power', 'crew_job', 'crew_department','spoken_languages','status',
                     'tagline','title','Keywords','cast','cast_name','crew','crew_name','genre_TV Movie','depart_Actors',
                     'cast_power','log_cast_power'],axis=1)

train_use.shape,test_use.shape

"""### Split the train data"""

trainy = train["log_revenue"]
X_train, X_test, y_train, y_test = train_test_split(train_use,trainy,test_size=0.3,random_state=100)

"""### XGboost Model"""

xgbmodel = xgb.XGBRegressor(max_depth=8, 
                            min_child_weight=3,
                            alpha = 0.5,
                            learning_rate=0.05, 
                            n_estimators=150, 
                            objective='reg:linear', 
                            gamma=0.01,  
                            silent=1,
                            subsample=0.8, 
                            colsample_bytree=0.8)

xgbmodel.fit(X_train, y_train)

pred_train1 = xgbmodel.predict(X_train)
pred_test1 = xgbmodel.predict(X_test)

print(np.sqrt(mean_squared_error(y_train, pred_train1)))
print(np.sqrt(mean_squared_error(y_test, pred_test1)))

pred_xgb = xgbmodel.predict(test_use)
pred_xgb = pd.DataFrame(np.exp(pred_xgb)-1,columns=["revenue"])
pred_xgb.head()

sub=pd.concat([test["id"], pred_xgb],axis=1)
sub.to_csv('xgb.csv',index=False)

"""### CATboost Model"""

catmodel = cat.CatBoostRegressor(iterations=2000, 
                                 learning_rate=0.01, 
                                 depth=8, 
                                 eval_metric='RMSE',
                                 colsample_bylevel=0.8,
                                 bagging_temperature = 0.2,
                                 metric_period = None,
                                 early_stopping_rounds=200)

catmodel.fit(X_train, y_train)

pred_train3 = catmodel.predict(X_train)
pred_test3 = catmodel.predict(X_test)

print(np.sqrt(mean_squared_error(y_train, pred_train3)))
print(np.sqrt(mean_squared_error(y_test, pred_test3)))

pred_cat = catmodel.predict(test_use)
pred_cat = pd.DataFrame(np.exp(pred_cat)-1,columns=["revenue"])
pred_cat.head()

sub2=pd.concat([test['id'], pred_cat],axis=1)
sub2.to_csv('cat.csv',index=False)

"""I first extract some more features that may help to predict. Then I split the test and train data, and use XGBboost and Catboost model to predict.
Since XGBoost doesn’t have an inbuilt method for categorical features, so I did one-hot encoding manually before fitting the model.<br>
As a result, the XGB model perform a little better than the Catboost model with a Kaggle score of 2.11139.

# Part 10 - Final Result

Report your highest score. Include a snapshot of your best score after submission as confirmation. Be sure to provide a link to your Kaggle profile. Make sure your profile includes your face and affiliation with SBU.

Kaggle Link: https://www.kaggle.com/haruka03

Highest Score: 2.11139

Number of entries: 10

![screenshot.png](data:image/png;base64,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)
"""